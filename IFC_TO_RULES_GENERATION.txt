# What You Can Generate From IFC to Help with Rules

## Overview

Your system currently extracts data from IFC files that can be used to **automatically generate, validate, and inform rules**. Here's what you can leverage:

---

## 1. **Currently Extracted Data (Automatic)**

### From Property Sets (PSet Extraction)
Your `extract_rules.py` module scans IFC property sets for rule-relevant parameters:

#### **Door Rules**
- Extract: `min_width_mm` from property sets containing "min" + "width"
- Creates: Parametric rule checking `door.width_mm < min_width_mm`
- Example PSet: `Pset_DoorCommon` → "FireRating", "MinimumWidth", etc.

#### **Space Rules**
- Extract: `min_area_m2` from property sets containing "min" + "area"
- Creates: Parametric rule checking `space.area_m2 < min_area_m2`
- Example PSet: `BaseQuantities` → "GrossFloorArea", "NetFloorArea"

#### **Building Rules**
- Extract: `max_occupancy_per_storey` from property sets containing "max" + "occupancy"
- Creates: Parametric rule checking occupancy compliance
- Example PSet: Custom occupancy-related property sets

### From Element Geometry & Structure
Your `extract_core.py` module extracts:

**Doors:**
- `width_mm`, `height_mm` (normalized from various units)
- `is_external` (connection type)
- `connected_spaces` (spatial relationships)
- Fire rating, material type (from PSet)

**Spaces:**
- `area_m2`, `volume_m3` (from BaseQuantities)
- `space_type` (office, corridor, etc.)
- Adjacency relationships
- Connected doors and windows

**Building:**
- Number of storeys
- Total floor area
- Building type classification
- Spatial hierarchy

---

## 2. **What You Can ADDITIONALLY Generate**

### A. **Rule Templates from Element Statistics**

```python
# Auto-generate rule thresholds from building analysis
min_door_width = percentile(all_doors.width_mm, 10)  # 10th percentile
avg_space_area = mean(all_spaces.area_m2)
occupancy_density = total_occupants / total_floor_area
```

**Benefits:**
- Baseline rules from existing data
- Detect outliers automatically
- Compare buildings

### B. **Element Classification Rules**

From IFC classification systems:
- **UniFormat** classifications (building sections)
- **OmniClass** classifications (construction/result)
- **IFC Type** hierarchies (IfcDoor, IfcSpace, etc.)

Generate rules like:
```json
{
  "rule": "classified_elements_must_have_system",
  "selector": { "by": "classification", "value": "UniFormat:B2010" }
}
```

### C. **Spatial Relationship Rules**

From `IfcRelContainedInSpatialStructure`:
- Elements in wrong storeys
- Orphaned elements (not in spatial structure)
- Discontinuous spatial hierarchies

```json
{
  "rule": "element_must_be_in_storey",
  "selector": { "by": "type", "value": "IfcWindow" },
  "condition": { "op": "!=", "lhs": "storey_id", "rhs": null }
}
```

### D. **Material & System Rules**

From Material property sets:
- Material compatibility checks
- Fire-rating requirements
- Acoustic performance

```json
{
  "rule": "exterior_doors_must_be_fireproof",
  "condition": {
    "op": "==",
    "lhs": "is_external",
    "rhs": true,
    "then_require": "fire_rating >= EI60"
  }
}
```

### E. **Compliance Standard Rules**

Map IFC data to standards:
- **IBC (International Building Code)**
- **ADA (Americans with Disabilities Act)**
- **NFPA (National Fire Protection Association)**
- **Local codes**

Examples:
```json
{
  "standard": "ADA 2010",
  "rule": "accessible_door_min_width_mm",
  "value": 900,
  "applies_to": ["doors_to_public_areas", "emergency_exits"]
}
```

### F. **Property Set Completeness Rules**

Track what data is missing:
```python
required_psets = {
  "IfcDoor": ["Pset_DoorCommon", "Pset_DoorSoundInsulation"],
  "IfcSpace": ["Pset_SpaceCommon", "BaseQuantities"],
  "IfcBuilding": ["Pset_BuildingCommon"]
}

missing = find_elements_without_psets(model, required_psets)
```

Generate rule:
```json
{
  "rule": "door_must_have_door_common_pset",
  "severity": "WARNING",
  "auto_generated": true
}
```

---

## 3. **Enhanced Analysis You Can Add**

### Building Performance Metrics
```python
metrics = {
  "door_accessibility_ratio": count(doors where width >= 900) / total_doors,
  "space_density": total_floor_area / num_spaces,
  "element_completeness": elements_with_psets / total_elements,
  "storey_consistency": detect_duplicate_storey_names(),
  "connection_coverage": elements_in_spatial_structure / total_elements
}
```

### Rule Confidence Scoring
```python
confidence = {
  "pset_found": 0.95,           # High: PSet explicitly defines parameter
  "inferred_from_geometry": 0.7, # Medium: Calculated from coordinates
  "heuristic": 0.5,              # Low: Guessed from element type
  "default": 0.3                 # Very low: Using fallback value
}
```

### Conflict Detection
```python
conflicts = {
  "overlapping_spaces": spaces_with_intersecting_bounds,
  "disconnected_doors": doors_not_connected_to_spaces,
  "duplicate_guids": elements_with_same_global_id,
  "circular_references": spatial_relationships_with_cycles
}
```

---

## 4. **Implementation in Your System**

### Current Hook: `extract_rules_from_graph()`

Location: `data_layer/extract_rules.py`

Currently scans property sets heuristically. You can enhance it to:

```python
def extract_rules_from_graph(graph: Mapping[str, Any]) -> Dict[str, Any]:
    """Enhanced extraction with multiple strategies."""
    
    # Strategy 1: Direct PSet extraction (current)
    rules = _heuristic_extract_from_pset(psets, etype, el_id)
    
    # Strategy 2: Statistical analysis (NEW)
    rules += _extract_statistical_rules(graph)
    
    # Strategy 3: Classification-based rules (NEW)
    rules += _extract_classification_rules(graph)
    
    # Strategy 4: Spatial compliance rules (NEW)
    rules += _extract_spatial_rules(graph)
    
    # Strategy 5: Standard mapping (NEW)
    rules += _extract_standard_compliance_rules(graph)
    
    return manifest
```

### Where Data Comes From

```
IFC File (.ifc)
    ↓
extract_core.py (Geometry, PSet, Relationships)
    ↓
Graph JSON (elements, spatial structure, properties)
    ↓
extract_rules.py (Current: PSet heuristics)
    ↓
Rules Manifest JSON
    ↓
Frontend: View Catalogue / Import / Edit / Append / Save
```

---

## 5. **Next Steps You Can Implement**

### Priority 1: Low Effort, High Value
- **Aggregate statistics** from all elements to generate baseline rules
- **Detect missing PSet data** and create validation rules
- **Extract classification codes** and map to requirements

### Priority 2: Medium Effort
- **Build standard compliance mappings** (ADA, IBC, etc.)
- **Generate spatial consistency rules** from relationship analysis
- **Calculate element completeness** metrics

### Priority 3: Advanced
- **Machine learning rule inference** from large building datasets
- **Conflict detection and resolution** suggestions
- **Cross-building pattern analysis** for rule harmonization

---

## 6. **Example: How to Use This**

**Scenario**: You upload a new IFC file

```
1. System extracts all element data
2. Identifies door with 850mm width (below standard 900mm)
3. Creates rule: "Door_ABC must be >= 900mm"
4. Adds to catalogue with confidence=0.95 (from PSet), severity=ERROR
5. You review in Rules Catalogue
6. Accept, modify, or delete
7. Save to custom_rules.json
8. Rules execute during compliance analysis
```

---

## Summary Table

| Data Type | Current | Can Add | Use Case |
|-----------|---------|---------|----------|
| **PSet Parameters** | ✅ Extracted | Expanded | Rule generation |
| **Element Geometry** | ✅ Extracted | Analysis | Statistics, baselines |
| **Spatial Structure** | ✅ Extracted | Validation | Structural rules |
| **Classifications** | ✅ Extracted | Mapping | Standard compliance |
| **Material Systems** | ❌ Not used | Add | Material rules |
| **Performance Data** | ❌ Not tracked | Add | Metrics & scoring |
| **Historical Rules** | ❌ Not stored | Add | Pattern learning |
| **Conflict Detection** | ❌ Not implemented | Add | Quality assurance |

---

**Recommendation**: Start with **Priority 1** (statistics + missing data detection) to unlock the most value with minimal effort!
